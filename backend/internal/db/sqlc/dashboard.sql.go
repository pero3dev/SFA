// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dashboard.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestKpiSnapshot = `-- name: GetLatestKpiSnapshot :many
SELECT
  ks.snapshot_at,
  ks.metric_key,
  ks.metric_value::double precision AS metric_value,
  ks.dimension_key,
  ks.dimensions
FROM kpi_snapshots ks
WHERE ks.tenant_id = $1
  AND snapshot_at = (
    SELECT max(snapshot_at)
    FROM kpi_snapshots ks2
    WHERE ks2.tenant_id = $1
  )
ORDER BY metric_key, dimension_key
`

type GetLatestKpiSnapshotRow struct {
	SnapshotAt   pgtype.Timestamptz `json:"snapshot_at"`
	MetricKey    string             `json:"metric_key"`
	MetricValue  float64            `json:"metric_value"`
	DimensionKey string             `json:"dimension_key"`
	Dimensions   []byte             `json:"dimensions"`
}

func (q *Queries) GetLatestKpiSnapshot(ctx context.Context, tenantID pgtype.UUID) ([]GetLatestKpiSnapshotRow, error) {
	rows, err := q.db.Query(ctx, getLatestKpiSnapshot, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLatestKpiSnapshotRow{}
	for rows.Next() {
		var i GetLatestKpiSnapshotRow
		if err := rows.Scan(
			&i.SnapshotAt,
			&i.MetricKey,
			&i.MetricValue,
			&i.DimensionKey,
			&i.Dimensions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPipelineSummary = `-- name: GetPipelineSummary :many
SELECT
  stage,
  count(*)::bigint AS deal_count,
  coalesce(sum(amount), 0)::double precision AS total_amount
FROM opportunities
WHERE tenant_id = $1
GROUP BY stage
ORDER BY stage
`

type GetPipelineSummaryRow struct {
	Stage       OpportunityStageEnum `json:"stage"`
	DealCount   int64                `json:"deal_count"`
	TotalAmount float64              `json:"total_amount"`
}

func (q *Queries) GetPipelineSummary(ctx context.Context, tenantID pgtype.UUID) ([]GetPipelineSummaryRow, error) {
	rows, err := q.db.Query(ctx, getPipelineSummary, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPipelineSummaryRow{}
	for rows.Next() {
		var i GetPipelineSummaryRow
		if err := rows.Scan(&i.Stage, &i.DealCount, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
