// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: opportunities.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const closeOpportunityAsLost = `-- name: CloseOpportunityAsLost :exec
UPDATE opportunities
SET stage = 'closed_lost',
    closed_at = now(),
    updated_at = now()
WHERE tenant_id = $1
  AND id = $2
`

type CloseOpportunityAsLostParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	OpportunityID pgtype.UUID `json:"opportunity_id"`
}

func (q *Queries) CloseOpportunityAsLost(ctx context.Context, arg CloseOpportunityAsLostParams) error {
	_, err := q.db.Exec(ctx, closeOpportunityAsLost, arg.TenantID, arg.OpportunityID)
	return err
}

const countOpportunities = `-- name: CountOpportunities :one
SELECT count(*)::bigint
FROM opportunities
WHERE tenant_id = $1
  AND ($2::opportunity_stage_enum IS NULL OR stage = $2)
  AND ($3::uuid IS NULL OR owner_user_id = $3)
`

type CountOpportunitiesParams struct {
	TenantID    pgtype.UUID              `json:"tenant_id"`
	Stage       NullOpportunityStageEnum `json:"stage"`
	OwnerUserID pgtype.UUID              `json:"owner_user_id"`
}

func (q *Queries) CountOpportunities(ctx context.Context, arg CountOpportunitiesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOpportunities, arg.TenantID, arg.Stage, arg.OwnerUserID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createActivity = `-- name: CreateActivity :one
INSERT INTO activities (
  tenant_id,
  opportunity_id,
  activity_type,
  subject,
  detail,
  activity_at,
  created_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
RETURNING id, tenant_id, opportunity_id, activity_type, subject, detail, activity_at, created_by, created_at
`

type CreateActivityParams struct {
	TenantID      pgtype.UUID        `json:"tenant_id"`
	OpportunityID pgtype.UUID        `json:"opportunity_id"`
	ActivityType  ActivityTypeEnum   `json:"activity_type"`
	Subject       string             `json:"subject"`
	Detail        pgtype.Text        `json:"detail"`
	ActivityAt    pgtype.Timestamptz `json:"activity_at"`
	CreatedBy     pgtype.UUID        `json:"created_by"`
}

func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) (Activity, error) {
	row := q.db.QueryRow(ctx, createActivity,
		arg.TenantID,
		arg.OpportunityID,
		arg.ActivityType,
		arg.Subject,
		arg.Detail,
		arg.ActivityAt,
		arg.CreatedBy,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OpportunityID,
		&i.ActivityType,
		&i.Subject,
		&i.Detail,
		&i.ActivityAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createOpportunity = `-- name: CreateOpportunity :one
INSERT INTO opportunities (
  tenant_id,
  account_id,
  contact_id,
  owner_user_id,
  name,
  stage,
  probability,
  amount,
  expected_close_date,
  memo,
  created_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  coalesce($6::opportunity_stage_enum, 'new_lead'),
  coalesce($7, 0),
  coalesce($8, 0),
  $9,
  $10,
  $11
)
RETURNING id, tenant_id, account_id, contact_id, owner_user_id, name, stage, probability, amount, expected_close_date, closed_at, memo, created_by, created_at, updated_at, next_action_at, next_action_note
`

type CreateOpportunityParams struct {
	TenantID          pgtype.UUID              `json:"tenant_id"`
	AccountID         pgtype.UUID              `json:"account_id"`
	ContactID         pgtype.UUID              `json:"contact_id"`
	OwnerUserID       pgtype.UUID              `json:"owner_user_id"`
	Name              string                   `json:"name"`
	Stage             NullOpportunityStageEnum `json:"stage"`
	Probability       interface{}              `json:"probability"`
	Amount            interface{}              `json:"amount"`
	ExpectedCloseDate pgtype.Date              `json:"expected_close_date"`
	Memo              pgtype.Text              `json:"memo"`
	CreatedBy         pgtype.UUID              `json:"created_by"`
}

func (q *Queries) CreateOpportunity(ctx context.Context, arg CreateOpportunityParams) (Opportunity, error) {
	row := q.db.QueryRow(ctx, createOpportunity,
		arg.TenantID,
		arg.AccountID,
		arg.ContactID,
		arg.OwnerUserID,
		arg.Name,
		arg.Stage,
		arg.Probability,
		arg.Amount,
		arg.ExpectedCloseDate,
		arg.Memo,
		arg.CreatedBy,
	)
	var i Opportunity
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AccountID,
		&i.ContactID,
		&i.OwnerUserID,
		&i.Name,
		&i.Stage,
		&i.Probability,
		&i.Amount,
		&i.ExpectedCloseDate,
		&i.ClosedAt,
		&i.Memo,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NextActionAt,
		&i.NextActionNote,
	)
	return i, err
}

const createOpportunityLoss = `-- name: CreateOpportunityLoss :one
INSERT INTO opportunity_losses (
  tenant_id,
  opportunity_id,
  reason,
  detail,
  lost_at,
  created_by
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  coalesce($5, now()),
  $6
)
RETURNING id, tenant_id, opportunity_id, reason, detail, lost_at, created_by, created_at
`

type CreateOpportunityLossParams struct {
	TenantID      pgtype.UUID    `json:"tenant_id"`
	OpportunityID pgtype.UUID    `json:"opportunity_id"`
	Reason        LossReasonEnum `json:"reason"`
	Detail        pgtype.Text    `json:"detail"`
	LostAt        interface{}    `json:"lost_at"`
	CreatedBy     pgtype.UUID    `json:"created_by"`
}

func (q *Queries) CreateOpportunityLoss(ctx context.Context, arg CreateOpportunityLossParams) (OpportunityLoss, error) {
	row := q.db.QueryRow(ctx, createOpportunityLoss,
		arg.TenantID,
		arg.OpportunityID,
		arg.Reason,
		arg.Detail,
		arg.LostAt,
		arg.CreatedBy,
	)
	var i OpportunityLoss
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OpportunityID,
		&i.Reason,
		&i.Detail,
		&i.LostAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
  tenant_id,
  opportunity_id,
  order_no,
  amount,
  status,
  ordered_on,
  note,
  created_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  coalesce($5::order_status_enum, 'pending'),
  $6,
  $7,
  $8
)
RETURNING id, tenant_id, opportunity_id, order_no, amount, status, ordered_on, note, created_by, created_at, updated_at
`

type CreateOrderParams struct {
	TenantID      pgtype.UUID         `json:"tenant_id"`
	OpportunityID pgtype.UUID         `json:"opportunity_id"`
	OrderNo       string              `json:"order_no"`
	Amount        pgtype.Numeric      `json:"amount"`
	Status        NullOrderStatusEnum `json:"status"`
	OrderedOn     pgtype.Date         `json:"ordered_on"`
	Note          pgtype.Text         `json:"note"`
	CreatedBy     pgtype.UUID         `json:"created_by"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.TenantID,
		arg.OpportunityID,
		arg.OrderNo,
		arg.Amount,
		arg.Status,
		arg.OrderedOn,
		arg.Note,
		arg.CreatedBy,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OpportunityID,
		&i.OrderNo,
		&i.Amount,
		&i.Status,
		&i.OrderedOn,
		&i.Note,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createQuote = `-- name: CreateQuote :one
INSERT INTO quotes (
  tenant_id,
  opportunity_id,
  quote_no,
  amount,
  status,
  issued_on,
  valid_until,
  note,
  created_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  coalesce($5::quote_status_enum, 'draft'),
  $6,
  $7,
  $8,
  $9
)
RETURNING id, tenant_id, opportunity_id, quote_no, amount, status, issued_on, valid_until, note, created_by, created_at, updated_at
`

type CreateQuoteParams struct {
	TenantID      pgtype.UUID         `json:"tenant_id"`
	OpportunityID pgtype.UUID         `json:"opportunity_id"`
	QuoteNo       string              `json:"quote_no"`
	Amount        pgtype.Numeric      `json:"amount"`
	Status        NullQuoteStatusEnum `json:"status"`
	IssuedOn      pgtype.Date         `json:"issued_on"`
	ValidUntil    pgtype.Date         `json:"valid_until"`
	Note          pgtype.Text         `json:"note"`
	CreatedBy     pgtype.UUID         `json:"created_by"`
}

func (q *Queries) CreateQuote(ctx context.Context, arg CreateQuoteParams) (Quote, error) {
	row := q.db.QueryRow(ctx, createQuote,
		arg.TenantID,
		arg.OpportunityID,
		arg.QuoteNo,
		arg.Amount,
		arg.Status,
		arg.IssuedOn,
		arg.ValidUntil,
		arg.Note,
		arg.CreatedBy,
	)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OpportunityID,
		&i.QuoteNo,
		&i.Amount,
		&i.Status,
		&i.IssuedOn,
		&i.ValidUntil,
		&i.Note,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActivitiesByOpportunity = `-- name: ListActivitiesByOpportunity :many
SELECT id, tenant_id, opportunity_id, activity_type, subject, detail, activity_at, created_by, created_at
FROM activities
WHERE tenant_id = $1
  AND opportunity_id = $2
ORDER BY activity_at DESC
LIMIT $4
OFFSET $3
`

type ListActivitiesByOpportunityParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	OpportunityID pgtype.UUID `json:"opportunity_id"`
	OffsetCount   int32       `json:"offset_count"`
	LimitCount    int32       `json:"limit_count"`
}

func (q *Queries) ListActivitiesByOpportunity(ctx context.Context, arg ListActivitiesByOpportunityParams) ([]Activity, error) {
	rows, err := q.db.Query(ctx, listActivitiesByOpportunity,
		arg.TenantID,
		arg.OpportunityID,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OpportunityID,
			&i.ActivityType,
			&i.Subject,
			&i.Detail,
			&i.ActivityAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpportunities = `-- name: ListOpportunities :many
SELECT id, tenant_id, account_id, contact_id, owner_user_id, name, stage, probability, amount, expected_close_date, closed_at, memo, created_by, created_at, updated_at, next_action_at, next_action_note
FROM opportunities
WHERE tenant_id = $1
  AND ($2::opportunity_stage_enum IS NULL OR stage = $2)
  AND ($3::uuid IS NULL OR owner_user_id = $3)
ORDER BY updated_at DESC
LIMIT $5
OFFSET $4
`

type ListOpportunitiesParams struct {
	TenantID    pgtype.UUID              `json:"tenant_id"`
	Stage       NullOpportunityStageEnum `json:"stage"`
	OwnerUserID pgtype.UUID              `json:"owner_user_id"`
	OffsetCount int32                    `json:"offset_count"`
	LimitCount  int32                    `json:"limit_count"`
}

func (q *Queries) ListOpportunities(ctx context.Context, arg ListOpportunitiesParams) ([]Opportunity, error) {
	rows, err := q.db.Query(ctx, listOpportunities,
		arg.TenantID,
		arg.Stage,
		arg.OwnerUserID,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Opportunity{}
	for rows.Next() {
		var i Opportunity
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AccountID,
			&i.ContactID,
			&i.OwnerUserID,
			&i.Name,
			&i.Stage,
			&i.Probability,
			&i.Amount,
			&i.ExpectedCloseDate,
			&i.ClosedAt,
			&i.Memo,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NextActionAt,
			&i.NextActionNote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByOpportunity = `-- name: ListOrdersByOpportunity :many
SELECT id, tenant_id, opportunity_id, order_no, amount, status, ordered_on, note, created_by, created_at, updated_at
FROM orders
WHERE tenant_id = $1
  AND opportunity_id = $2
ORDER BY created_at DESC
`

type ListOrdersByOpportunityParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	OpportunityID pgtype.UUID `json:"opportunity_id"`
}

func (q *Queries) ListOrdersByOpportunity(ctx context.Context, arg ListOrdersByOpportunityParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByOpportunity, arg.TenantID, arg.OpportunityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OpportunityID,
			&i.OrderNo,
			&i.Amount,
			&i.Status,
			&i.OrderedOn,
			&i.Note,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesByOpportunity = `-- name: ListQuotesByOpportunity :many
SELECT id, tenant_id, opportunity_id, quote_no, amount, status, issued_on, valid_until, note, created_by, created_at, updated_at
FROM quotes
WHERE tenant_id = $1
  AND opportunity_id = $2
ORDER BY created_at DESC
`

type ListQuotesByOpportunityParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	OpportunityID pgtype.UUID `json:"opportunity_id"`
}

func (q *Queries) ListQuotesByOpportunity(ctx context.Context, arg ListQuotesByOpportunityParams) ([]Quote, error) {
	rows, err := q.db.Query(ctx, listQuotesByOpportunity, arg.TenantID, arg.OpportunityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OpportunityID,
			&i.QuoteNo,
			&i.Amount,
			&i.Status,
			&i.IssuedOn,
			&i.ValidUntil,
			&i.Note,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOpportunity = `-- name: UpdateOpportunity :one
UPDATE opportunities
SET
  contact_id = coalesce($1, contact_id),
  owner_user_id = coalesce($2, owner_user_id),
  name = coalesce($3, name),
  stage = coalesce($4::opportunity_stage_enum, stage),
  probability = coalesce($5, probability),
  amount = coalesce($6, amount),
  expected_close_date = coalesce($7, expected_close_date),
  memo = coalesce($8, memo),
  updated_at = now()
WHERE tenant_id = $9
  AND id = $10
RETURNING id, tenant_id, account_id, contact_id, owner_user_id, name, stage, probability, amount, expected_close_date, closed_at, memo, created_by, created_at, updated_at, next_action_at, next_action_note
`

type UpdateOpportunityParams struct {
	ContactID         pgtype.UUID              `json:"contact_id"`
	OwnerUserID       pgtype.UUID              `json:"owner_user_id"`
	Name              pgtype.Text              `json:"name"`
	Stage             NullOpportunityStageEnum `json:"stage"`
	Probability       pgtype.Int2              `json:"probability"`
	Amount            pgtype.Numeric           `json:"amount"`
	ExpectedCloseDate pgtype.Date              `json:"expected_close_date"`
	Memo              pgtype.Text              `json:"memo"`
	TenantID          pgtype.UUID              `json:"tenant_id"`
	OpportunityID     pgtype.UUID              `json:"opportunity_id"`
}

func (q *Queries) UpdateOpportunity(ctx context.Context, arg UpdateOpportunityParams) (Opportunity, error) {
	row := q.db.QueryRow(ctx, updateOpportunity,
		arg.ContactID,
		arg.OwnerUserID,
		arg.Name,
		arg.Stage,
		arg.Probability,
		arg.Amount,
		arg.ExpectedCloseDate,
		arg.Memo,
		arg.TenantID,
		arg.OpportunityID,
	)
	var i Opportunity
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AccountID,
		&i.ContactID,
		&i.OwnerUserID,
		&i.Name,
		&i.Stage,
		&i.Probability,
		&i.Amount,
		&i.ExpectedCloseDate,
		&i.ClosedAt,
		&i.Memo,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NextActionAt,
		&i.NextActionNote,
	)
	return i, err
}
