// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAccounts = `-- name: CountAccounts :one
SELECT count(*)::bigint
FROM accounts
WHERE tenant_id = $1
  AND ($2::account_status_enum IS NULL OR status = $2)
  AND ($3::text IS NULL OR name ILIKE ('%' || $3 || '%'))
`

type CountAccountsParams struct {
	TenantID  pgtype.UUID           `json:"tenant_id"`
	Status    NullAccountStatusEnum `json:"status"`
	NameQuery pgtype.Text           `json:"name_query"`
}

func (q *Queries) CountAccounts(ctx context.Context, arg CountAccountsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAccounts, arg.TenantID, arg.Status, arg.NameQuery)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (
  tenant_id,
  owner_user_id,
  name,
  industry,
  website,
  phone,
  status,
  memo,
  created_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  coalesce($7::account_status_enum, 'prospect'),
  $8,
  $9
)
RETURNING id, tenant_id, owner_user_id, name, industry, website, phone, status, memo, created_by, created_at, updated_at
`

type CreateAccountParams struct {
	TenantID    pgtype.UUID           `json:"tenant_id"`
	OwnerUserID pgtype.UUID           `json:"owner_user_id"`
	Name        string                `json:"name"`
	Industry    pgtype.Text           `json:"industry"`
	Website     pgtype.Text           `json:"website"`
	Phone       pgtype.Text           `json:"phone"`
	Status      NullAccountStatusEnum `json:"status"`
	Memo        pgtype.Text           `json:"memo"`
	CreatedBy   pgtype.UUID           `json:"created_by"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.TenantID,
		arg.OwnerUserID,
		arg.Name,
		arg.Industry,
		arg.Website,
		arg.Phone,
		arg.Status,
		arg.Memo,
		arg.CreatedBy,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OwnerUserID,
		&i.Name,
		&i.Industry,
		&i.Website,
		&i.Phone,
		&i.Status,
		&i.Memo,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createContact = `-- name: CreateContact :one
INSERT INTO contacts (
  tenant_id,
  account_id,
  location_id,
  owner_user_id,
  full_name,
  department,
  title,
  email,
  phone,
  is_primary,
  memo,
  created_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  coalesce($10, false),
  $11,
  $12
)
RETURNING id, tenant_id, account_id, location_id, owner_user_id, full_name, department, title, email, phone, is_primary, memo, created_by, created_at, updated_at
`

type CreateContactParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	AccountID   pgtype.UUID `json:"account_id"`
	LocationID  pgtype.UUID `json:"location_id"`
	OwnerUserID pgtype.UUID `json:"owner_user_id"`
	FullName    string      `json:"full_name"`
	Department  pgtype.Text `json:"department"`
	Title       pgtype.Text `json:"title"`
	Email       pgtype.Text `json:"email"`
	Phone       pgtype.Text `json:"phone"`
	IsPrimary   interface{} `json:"is_primary"`
	Memo        pgtype.Text `json:"memo"`
	CreatedBy   pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) (Contact, error) {
	row := q.db.QueryRow(ctx, createContact,
		arg.TenantID,
		arg.AccountID,
		arg.LocationID,
		arg.OwnerUserID,
		arg.FullName,
		arg.Department,
		arg.Title,
		arg.Email,
		arg.Phone,
		arg.IsPrimary,
		arg.Memo,
		arg.CreatedBy,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AccountID,
		&i.LocationID,
		&i.OwnerUserID,
		&i.FullName,
		&i.Department,
		&i.Title,
		&i.Email,
		&i.Phone,
		&i.IsPrimary,
		&i.Memo,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO account_locations (
  tenant_id,
  account_id,
  name,
  country,
  postal_code,
  prefecture,
  city,
  address_line1,
  address_line2
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9
)
RETURNING id, tenant_id, account_id, name, country, postal_code, prefecture, city, address_line1, address_line2, created_at, updated_at
`

type CreateLocationParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	AccountID    pgtype.UUID `json:"account_id"`
	Name         string      `json:"name"`
	Country      pgtype.Text `json:"country"`
	PostalCode   pgtype.Text `json:"postal_code"`
	Prefecture   pgtype.Text `json:"prefecture"`
	City         pgtype.Text `json:"city"`
	AddressLine1 pgtype.Text `json:"address_line1"`
	AddressLine2 pgtype.Text `json:"address_line2"`
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (AccountLocation, error) {
	row := q.db.QueryRow(ctx, createLocation,
		arg.TenantID,
		arg.AccountID,
		arg.Name,
		arg.Country,
		arg.PostalCode,
		arg.Prefecture,
		arg.City,
		arg.AddressLine1,
		arg.AddressLine2,
	)
	var i AccountLocation
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AccountID,
		&i.Name,
		&i.Country,
		&i.PostalCode,
		&i.Prefecture,
		&i.City,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, tenant_id, owner_user_id, name, industry, website, phone, status, memo, created_by, created_at, updated_at
FROM accounts
WHERE tenant_id = $1
  AND ($2::account_status_enum IS NULL OR status = $2)
  AND ($3::text IS NULL OR name ILIKE ('%' || $3 || '%'))
ORDER BY updated_at DESC
LIMIT $5
OFFSET $4
`

type ListAccountsParams struct {
	TenantID    pgtype.UUID           `json:"tenant_id"`
	Status      NullAccountStatusEnum `json:"status"`
	NameQuery   pgtype.Text           `json:"name_query"`
	OffsetCount int32                 `json:"offset_count"`
	LimitCount  int32                 `json:"limit_count"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts,
		arg.TenantID,
		arg.Status,
		arg.NameQuery,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OwnerUserID,
			&i.Name,
			&i.Industry,
			&i.Website,
			&i.Phone,
			&i.Status,
			&i.Memo,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactsByAccount = `-- name: ListContactsByAccount :many
SELECT id, tenant_id, account_id, location_id, owner_user_id, full_name, department, title, email, phone, is_primary, memo, created_by, created_at, updated_at
FROM contacts
WHERE tenant_id = $1
  AND account_id = $2
ORDER BY updated_at DESC
LIMIT $4
OFFSET $3
`

type ListContactsByAccountParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	AccountID   pgtype.UUID `json:"account_id"`
	OffsetCount int32       `json:"offset_count"`
	LimitCount  int32       `json:"limit_count"`
}

func (q *Queries) ListContactsByAccount(ctx context.Context, arg ListContactsByAccountParams) ([]Contact, error) {
	rows, err := q.db.Query(ctx, listContactsByAccount,
		arg.TenantID,
		arg.AccountID,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AccountID,
			&i.LocationID,
			&i.OwnerUserID,
			&i.FullName,
			&i.Department,
			&i.Title,
			&i.Email,
			&i.Phone,
			&i.IsPrimary,
			&i.Memo,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocationsByAccount = `-- name: ListLocationsByAccount :many
SELECT id, tenant_id, account_id, name, country, postal_code, prefecture, city, address_line1, address_line2, created_at, updated_at
FROM account_locations
WHERE tenant_id = $1
  AND account_id = $2
ORDER BY updated_at DESC
`

type ListLocationsByAccountParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	AccountID pgtype.UUID `json:"account_id"`
}

func (q *Queries) ListLocationsByAccount(ctx context.Context, arg ListLocationsByAccountParams) ([]AccountLocation, error) {
	rows, err := q.db.Query(ctx, listLocationsByAccount, arg.TenantID, arg.AccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountLocation{}
	for rows.Next() {
		var i AccountLocation
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AccountID,
			&i.Name,
			&i.Country,
			&i.PostalCode,
			&i.Prefecture,
			&i.City,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET
  owner_user_id = coalesce($1, owner_user_id),
  name = coalesce($2, name),
  industry = coalesce($3, industry),
  website = coalesce($4, website),
  phone = coalesce($5, phone),
  status = coalesce($6::account_status_enum, status),
  memo = coalesce($7, memo),
  updated_at = now()
WHERE tenant_id = $8
  AND id = $9
RETURNING id, tenant_id, owner_user_id, name, industry, website, phone, status, memo, created_by, created_at, updated_at
`

type UpdateAccountParams struct {
	OwnerUserID pgtype.UUID           `json:"owner_user_id"`
	Name        pgtype.Text           `json:"name"`
	Industry    pgtype.Text           `json:"industry"`
	Website     pgtype.Text           `json:"website"`
	Phone       pgtype.Text           `json:"phone"`
	Status      NullAccountStatusEnum `json:"status"`
	Memo        pgtype.Text           `json:"memo"`
	TenantID    pgtype.UUID           `json:"tenant_id"`
	AccountID   pgtype.UUID           `json:"account_id"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.OwnerUserID,
		arg.Name,
		arg.Industry,
		arg.Website,
		arg.Phone,
		arg.Status,
		arg.Memo,
		arg.TenantID,
		arg.AccountID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OwnerUserID,
		&i.Name,
		&i.Industry,
		&i.Website,
		&i.Phone,
		&i.Status,
		&i.Memo,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
