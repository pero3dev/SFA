// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: feature_pack.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApprovalRequest = `-- name: CreateApprovalRequest :one
INSERT INTO approval_requests (
  tenant_id,
  entity_type,
  entity_id,
  requested_by,
  approver_user_id,
  reason
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
)
RETURNING id, tenant_id, entity_type, entity_id, requested_by, approver_user_id, status, reason, decision_note, decided_at, created_at, updated_at
`

type CreateApprovalRequestParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	EntityType     string      `json:"entity_type"`
	EntityID       pgtype.UUID `json:"entity_id"`
	RequestedBy    pgtype.UUID `json:"requested_by"`
	ApproverUserID pgtype.UUID `json:"approver_user_id"`
	Reason         string      `json:"reason"`
}

func (q *Queries) CreateApprovalRequest(ctx context.Context, arg CreateApprovalRequestParams) (ApprovalRequest, error) {
	row := q.db.QueryRow(ctx, createApprovalRequest,
		arg.TenantID,
		arg.EntityType,
		arg.EntityID,
		arg.RequestedBy,
		arg.ApproverUserID,
		arg.Reason,
	)
	var i ApprovalRequest
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EntityType,
		&i.EntityID,
		&i.RequestedBy,
		&i.ApproverUserID,
		&i.Status,
		&i.Reason,
		&i.DecisionNote,
		&i.DecidedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createIntegrationEvent = `-- name: CreateIntegrationEvent :one
INSERT INTO integration_events (
  tenant_id,
  provider,
  integration_type,
  external_event_id,
  event_type,
  payload,
  linked_account_id,
  linked_contact_id,
  linked_opportunity_id,
  occurred_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  coalesce($6, '{}'::jsonb),
  $7,
  $8,
  $9,
  $10
)
RETURNING id, tenant_id, provider, integration_type, external_event_id, event_type, payload, linked_account_id, linked_contact_id, linked_opportunity_id, occurred_at, created_at
`

type CreateIntegrationEventParams struct {
	TenantID            pgtype.UUID             `json:"tenant_id"`
	Provider            IntegrationProviderEnum `json:"provider"`
	IntegrationType     IntegrationTypeEnum     `json:"integration_type"`
	ExternalEventID     pgtype.Text             `json:"external_event_id"`
	EventType           string                  `json:"event_type"`
	Payload             interface{}             `json:"payload"`
	LinkedAccountID     pgtype.UUID             `json:"linked_account_id"`
	LinkedContactID     pgtype.UUID             `json:"linked_contact_id"`
	LinkedOpportunityID pgtype.UUID             `json:"linked_opportunity_id"`
	OccurredAt          pgtype.Timestamptz      `json:"occurred_at"`
}

func (q *Queries) CreateIntegrationEvent(ctx context.Context, arg CreateIntegrationEventParams) (IntegrationEvent, error) {
	row := q.db.QueryRow(ctx, createIntegrationEvent,
		arg.TenantID,
		arg.Provider,
		arg.IntegrationType,
		arg.ExternalEventID,
		arg.EventType,
		arg.Payload,
		arg.LinkedAccountID,
		arg.LinkedContactID,
		arg.LinkedOpportunityID,
		arg.OccurredAt,
	)
	var i IntegrationEvent
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Provider,
		&i.IntegrationType,
		&i.ExternalEventID,
		&i.EventType,
		&i.Payload,
		&i.LinkedAccountID,
		&i.LinkedContactID,
		&i.LinkedOpportunityID,
		&i.OccurredAt,
		&i.CreatedAt,
	)
	return i, err
}

const decideApprovalRequest = `-- name: DecideApprovalRequest :one
UPDATE approval_requests
SET
  status = $1,
  decision_note = $2,
  decided_at = now(),
  updated_at = now()
WHERE tenant_id = $3
  AND id = $4
RETURNING id, tenant_id, entity_type, entity_id, requested_by, approver_user_id, status, reason, decision_note, decided_at, created_at, updated_at
`

type DecideApprovalRequestParams struct {
	Status       ApprovalStatusEnum `json:"status"`
	DecisionNote pgtype.Text        `json:"decision_note"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	ApprovalID   pgtype.UUID        `json:"approval_id"`
}

func (q *Queries) DecideApprovalRequest(ctx context.Context, arg DecideApprovalRequestParams) (ApprovalRequest, error) {
	row := q.db.QueryRow(ctx, decideApprovalRequest,
		arg.Status,
		arg.DecisionNote,
		arg.TenantID,
		arg.ApprovalID,
	)
	var i ApprovalRequest
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EntityType,
		&i.EntityID,
		&i.RequestedBy,
		&i.ApproverUserID,
		&i.Status,
		&i.Reason,
		&i.DecisionNote,
		&i.DecidedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const exportAccountsRows = `-- name: ExportAccountsRows :many
SELECT
  id,
  owner_user_id,
  name,
  industry,
  website,
  phone,
  status,
  memo,
  created_at,
  updated_at
FROM accounts
WHERE tenant_id = $1
ORDER BY created_at DESC
`

type ExportAccountsRowsRow struct {
	ID          pgtype.UUID        `json:"id"`
	OwnerUserID pgtype.UUID        `json:"owner_user_id"`
	Name        string             `json:"name"`
	Industry    pgtype.Text        `json:"industry"`
	Website     pgtype.Text        `json:"website"`
	Phone       pgtype.Text        `json:"phone"`
	Status      AccountStatusEnum  `json:"status"`
	Memo        pgtype.Text        `json:"memo"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ExportAccountsRows(ctx context.Context, tenantID pgtype.UUID) ([]ExportAccountsRowsRow, error) {
	rows, err := q.db.Query(ctx, exportAccountsRows, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExportAccountsRowsRow{}
	for rows.Next() {
		var i ExportAccountsRowsRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Industry,
			&i.Website,
			&i.Phone,
			&i.Status,
			&i.Memo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const exportOpportunitiesRows = `-- name: ExportOpportunitiesRows :many
SELECT
  id,
  account_id,
  contact_id,
  owner_user_id,
  name,
  stage,
  probability,
  amount::double precision AS amount,
  expected_close_date,
  next_action_at,
  next_action_note,
  created_at,
  updated_at
FROM opportunities
WHERE tenant_id = $1
ORDER BY created_at DESC
`

type ExportOpportunitiesRowsRow struct {
	ID                pgtype.UUID          `json:"id"`
	AccountID         pgtype.UUID          `json:"account_id"`
	ContactID         pgtype.UUID          `json:"contact_id"`
	OwnerUserID       pgtype.UUID          `json:"owner_user_id"`
	Name              string               `json:"name"`
	Stage             OpportunityStageEnum `json:"stage"`
	Probability       int16                `json:"probability"`
	Amount            float64              `json:"amount"`
	ExpectedCloseDate pgtype.Date          `json:"expected_close_date"`
	NextActionAt      pgtype.Timestamptz   `json:"next_action_at"`
	NextActionNote    pgtype.Text          `json:"next_action_note"`
	CreatedAt         pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz   `json:"updated_at"`
}

func (q *Queries) ExportOpportunitiesRows(ctx context.Context, tenantID pgtype.UUID) ([]ExportOpportunitiesRowsRow, error) {
	rows, err := q.db.Query(ctx, exportOpportunitiesRows, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExportOpportunitiesRowsRow{}
	for rows.Next() {
		var i ExportOpportunitiesRowsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.ContactID,
			&i.OwnerUserID,
			&i.Name,
			&i.Stage,
			&i.Probability,
			&i.Amount,
			&i.ExpectedCloseDate,
			&i.NextActionAt,
			&i.NextActionNote,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForecastSummary = `-- name: GetForecastSummary :many
SELECT
  o.owner_user_id,
  to_char(date_trunc('month', coalesce(o.expected_close_date::timestamptz, now())), 'YYYY-MM') AS month_bucket,
  count(*)::bigint AS deal_count,
  coalesce(sum(o.amount), 0)::double precision AS pipeline_amount,
  coalesce(sum(o.amount * (o.probability::numeric / 100.0)), 0)::double precision AS weighted_amount
FROM opportunities o
WHERE o.tenant_id = $1
  AND o.stage NOT IN ('closed_won', 'closed_lost')
GROUP BY o.owner_user_id, to_char(date_trunc('month', coalesce(o.expected_close_date::timestamptz, now())), 'YYYY-MM')
ORDER BY month_bucket ASC, o.owner_user_id ASC
`

type GetForecastSummaryRow struct {
	OwnerUserID    pgtype.UUID `json:"owner_user_id"`
	MonthBucket    string      `json:"month_bucket"`
	DealCount      int64       `json:"deal_count"`
	PipelineAmount float64     `json:"pipeline_amount"`
	WeightedAmount float64     `json:"weighted_amount"`
}

func (q *Queries) GetForecastSummary(ctx context.Context, tenantID pgtype.UUID) ([]GetForecastSummaryRow, error) {
	rows, err := q.db.Query(ctx, getForecastSummary, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetForecastSummaryRow{}
	for rows.Next() {
		var i GetForecastSummaryRow
		if err := rows.Scan(
			&i.OwnerUserID,
			&i.MonthBucket,
			&i.DealCount,
			&i.PipelineAmount,
			&i.WeightedAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLossReasonAnalysis = `-- name: GetLossReasonAnalysis :many
SELECT
  l.reason,
  count(*)::bigint AS lost_count,
  coalesce(sum(o.amount), 0)::double precision AS lost_amount
FROM opportunity_losses l
JOIN opportunities o ON o.id = l.opportunity_id
WHERE l.tenant_id = $1
GROUP BY l.reason
ORDER BY lost_count DESC, lost_amount DESC
`

type GetLossReasonAnalysisRow struct {
	Reason     LossReasonEnum `json:"reason"`
	LostCount  int64          `json:"lost_count"`
	LostAmount float64        `json:"lost_amount"`
}

func (q *Queries) GetLossReasonAnalysis(ctx context.Context, tenantID pgtype.UUID) ([]GetLossReasonAnalysisRow, error) {
	rows, err := q.db.Query(ctx, getLossReasonAnalysis, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLossReasonAnalysisRow{}
	for rows.Next() {
		var i GetLossReasonAnalysisRow
		if err := rows.Scan(&i.Reason, &i.LostCount, &i.LostAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApprovalRequests = `-- name: ListApprovalRequests :many
SELECT id, tenant_id, entity_type, entity_id, requested_by, approver_user_id, status, reason, decision_note, decided_at, created_at, updated_at
FROM approval_requests
WHERE tenant_id = $1
  AND ($2::approval_status_enum IS NULL OR status = $2)
ORDER BY created_at DESC
LIMIT $4
OFFSET $3
`

type ListApprovalRequestsParams struct {
	TenantID    pgtype.UUID            `json:"tenant_id"`
	Status      NullApprovalStatusEnum `json:"status"`
	OffsetCount int32                  `json:"offset_count"`
	LimitCount  int32                  `json:"limit_count"`
}

func (q *Queries) ListApprovalRequests(ctx context.Context, arg ListApprovalRequestsParams) ([]ApprovalRequest, error) {
	rows, err := q.db.Query(ctx, listApprovalRequests,
		arg.TenantID,
		arg.Status,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApprovalRequest{}
	for rows.Next() {
		var i ApprovalRequest
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EntityType,
			&i.EntityID,
			&i.RequestedBy,
			&i.ApproverUserID,
			&i.Status,
			&i.Reason,
			&i.DecisionNote,
			&i.DecidedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDealHealth = `-- name: ListDealHealth :many
SELECT
  o.id,
  o.name,
  o.stage,
  o.probability,
  o.amount::double precision AS amount,
  coalesce(last_activity.last_activity_at, o.created_at)::timestamptz AS last_activity_at,
  GREATEST(
    0,
    LEAST(
      100,
      100
      - LEAST(60, EXTRACT(DAY FROM (now() - coalesce(last_activity.last_activity_at, o.created_at)))::int * 2)
      - LEAST(30, EXTRACT(DAY FROM (now() - o.updated_at))::int)
      + CASE
          WHEN o.probability >= 70 THEN 10
          WHEN o.probability <= 20 THEN -10
          ELSE 0
        END
    )
  )::int AS health_score
FROM opportunities o
LEFT JOIN LATERAL (
  SELECT max(a.activity_at) AS last_activity_at
  FROM activities a
  WHERE a.tenant_id = o.tenant_id
    AND a.opportunity_id = o.id
) AS last_activity ON true
WHERE o.tenant_id = $1
ORDER BY health_score ASC, o.updated_at ASC
LIMIT $3
OFFSET $2
`

type ListDealHealthParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	OffsetCount int32       `json:"offset_count"`
	LimitCount  int32       `json:"limit_count"`
}

type ListDealHealthRow struct {
	ID             pgtype.UUID          `json:"id"`
	Name           string               `json:"name"`
	Stage          OpportunityStageEnum `json:"stage"`
	Probability    int16                `json:"probability"`
	Amount         float64              `json:"amount"`
	LastActivityAt pgtype.Timestamptz   `json:"last_activity_at"`
	HealthScore    int32                `json:"health_score"`
}

func (q *Queries) ListDealHealth(ctx context.Context, arg ListDealHealthParams) ([]ListDealHealthRow, error) {
	rows, err := q.db.Query(ctx, listDealHealth, arg.TenantID, arg.OffsetCount, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDealHealthRow{}
	for rows.Next() {
		var i ListDealHealthRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Stage,
			&i.Probability,
			&i.Amount,
			&i.LastActivityAt,
			&i.HealthScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDuplicateCandidates = `-- name: ListDuplicateCandidates :many
SELECT
  'account_name'::text AS duplicate_type,
  a1.id AS primary_id,
  a2.id AS duplicate_id,
  a1.name AS match_value
FROM accounts a1
JOIN accounts a2
  ON a1.tenant_id = a2.tenant_id
 AND a1.id < a2.id
 AND lower(a1.name) = lower(a2.name)
WHERE a1.tenant_id = $1
UNION ALL
SELECT
  'account_website'::text AS duplicate_type,
  a1.id AS primary_id,
  a2.id AS duplicate_id,
  a1.website AS match_value
FROM accounts a1
JOIN accounts a2
  ON a1.tenant_id = a2.tenant_id
 AND a1.id < a2.id
 AND a1.website IS NOT NULL
 AND a2.website IS NOT NULL
 AND lower(a1.website) = lower(a2.website)
WHERE a1.tenant_id = $1
UNION ALL
SELECT
  'contact_email'::text AS duplicate_type,
  c1.id AS primary_id,
  c2.id AS duplicate_id,
  c1.email AS match_value
FROM contacts c1
JOIN contacts c2
  ON c1.tenant_id = c2.tenant_id
 AND c1.id < c2.id
 AND c1.email IS NOT NULL
 AND c2.email IS NOT NULL
 AND lower(c1.email) = lower(c2.email)
WHERE c1.tenant_id = $1
ORDER BY duplicate_type, match_value
`

type ListDuplicateCandidatesRow struct {
	DuplicateType string      `json:"duplicate_type"`
	PrimaryID     pgtype.UUID `json:"primary_id"`
	DuplicateID   pgtype.UUID `json:"duplicate_id"`
	MatchValue    string      `json:"match_value"`
}

func (q *Queries) ListDuplicateCandidates(ctx context.Context, tenantID pgtype.UUID) ([]ListDuplicateCandidatesRow, error) {
	rows, err := q.db.Query(ctx, listDuplicateCandidates, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDuplicateCandidatesRow{}
	for rows.Next() {
		var i ListDuplicateCandidatesRow
		if err := rows.Scan(
			&i.DuplicateType,
			&i.PrimaryID,
			&i.DuplicateID,
			&i.MatchValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIntegrationConnections = `-- name: ListIntegrationConnections :many
SELECT id, tenant_id, user_id, provider, integration_type, external_account_id, status, access_token, refresh_token, expires_at, scopes, created_at, updated_at
FROM integration_connections
WHERE tenant_id = $1
ORDER BY updated_at DESC
`

func (q *Queries) ListIntegrationConnections(ctx context.Context, tenantID pgtype.UUID) ([]IntegrationConnection, error) {
	rows, err := q.db.Query(ctx, listIntegrationConnections, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IntegrationConnection{}
	for rows.Next() {
		var i IntegrationConnection
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.Provider,
			&i.IntegrationType,
			&i.ExternalAccountID,
			&i.Status,
			&i.AccessToken,
			&i.RefreshToken,
			&i.ExpiresAt,
			&i.Scopes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIntegrationEvents = `-- name: ListIntegrationEvents :many
SELECT id, tenant_id, provider, integration_type, external_event_id, event_type, payload, linked_account_id, linked_contact_id, linked_opportunity_id, occurred_at, created_at
FROM integration_events
WHERE tenant_id = $1
ORDER BY occurred_at DESC
LIMIT $3
OFFSET $2
`

type ListIntegrationEventsParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	OffsetCount int32       `json:"offset_count"`
	LimitCount  int32       `json:"limit_count"`
}

func (q *Queries) ListIntegrationEvents(ctx context.Context, arg ListIntegrationEventsParams) ([]IntegrationEvent, error) {
	rows, err := q.db.Query(ctx, listIntegrationEvents, arg.TenantID, arg.OffsetCount, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IntegrationEvent{}
	for rows.Next() {
		var i IntegrationEvent
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Provider,
			&i.IntegrationType,
			&i.ExternalEventID,
			&i.EventType,
			&i.Payload,
			&i.LinkedAccountID,
			&i.LinkedContactID,
			&i.LinkedOpportunityID,
			&i.OccurredAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNextActions = `-- name: ListNextActions :many
SELECT
  o.id,
  o.name,
  o.stage,
  o.next_action_at,
  o.next_action_note,
  a.name AS account_name
FROM opportunities o
JOIN accounts a ON a.id = o.account_id
WHERE o.tenant_id = $1
  AND o.next_action_at IS NOT NULL
  AND ($2::timestamptz IS NULL OR o.next_action_at <= $2::timestamptz)
ORDER BY o.next_action_at ASC
LIMIT $4
OFFSET $3
`

type ListNextActionsParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	DueBefore   pgtype.Timestamptz `json:"due_before"`
	OffsetCount int32              `json:"offset_count"`
	LimitCount  int32              `json:"limit_count"`
}

type ListNextActionsRow struct {
	ID             pgtype.UUID          `json:"id"`
	Name           string               `json:"name"`
	Stage          OpportunityStageEnum `json:"stage"`
	NextActionAt   pgtype.Timestamptz   `json:"next_action_at"`
	NextActionNote pgtype.Text          `json:"next_action_note"`
	AccountName    string               `json:"account_name"`
}

func (q *Queries) ListNextActions(ctx context.Context, arg ListNextActionsParams) ([]ListNextActionsRow, error) {
	rows, err := q.db.Query(ctx, listNextActions,
		arg.TenantID,
		arg.DueBefore,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNextActionsRow{}
	for rows.Next() {
		var i ListNextActionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Stage,
			&i.NextActionAt,
			&i.NextActionNote,
			&i.AccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOpportunityNextAction = `-- name: UpdateOpportunityNextAction :one
UPDATE opportunities
SET
  next_action_at = $1,
  next_action_note = $2,
  updated_at = now()
WHERE tenant_id = $3
  AND id = $4
RETURNING id, tenant_id, account_id, contact_id, owner_user_id, name, stage, probability, amount, expected_close_date, closed_at, memo, created_by, created_at, updated_at, next_action_at, next_action_note
`

type UpdateOpportunityNextActionParams struct {
	NextActionAt   pgtype.Timestamptz `json:"next_action_at"`
	NextActionNote pgtype.Text        `json:"next_action_note"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	OpportunityID  pgtype.UUID        `json:"opportunity_id"`
}

func (q *Queries) UpdateOpportunityNextAction(ctx context.Context, arg UpdateOpportunityNextActionParams) (Opportunity, error) {
	row := q.db.QueryRow(ctx, updateOpportunityNextAction,
		arg.NextActionAt,
		arg.NextActionNote,
		arg.TenantID,
		arg.OpportunityID,
	)
	var i Opportunity
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AccountID,
		&i.ContactID,
		&i.OwnerUserID,
		&i.Name,
		&i.Stage,
		&i.Probability,
		&i.Amount,
		&i.ExpectedCloseDate,
		&i.ClosedAt,
		&i.Memo,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NextActionAt,
		&i.NextActionNote,
	)
	return i, err
}

const upsertIntegrationConnection = `-- name: UpsertIntegrationConnection :one
INSERT INTO integration_connections (
  tenant_id,
  user_id,
  provider,
  integration_type,
  external_account_id,
  status,
  access_token,
  refresh_token,
  expires_at,
  scopes
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  coalesce($6::integration_status_enum, 'active'),
  $7,
  $8,
  $9,
  coalesce($10, '{}'::text[])
)
ON CONFLICT (tenant_id, user_id, provider, integration_type, external_account_id)
DO UPDATE SET
  status = excluded.status,
  access_token = excluded.access_token,
  refresh_token = excluded.refresh_token,
  expires_at = excluded.expires_at,
  scopes = excluded.scopes,
  updated_at = now()
RETURNING id, tenant_id, user_id, provider, integration_type, external_account_id, status, access_token, refresh_token, expires_at, scopes, created_at, updated_at
`

type UpsertIntegrationConnectionParams struct {
	TenantID          pgtype.UUID               `json:"tenant_id"`
	UserID            pgtype.UUID               `json:"user_id"`
	Provider          IntegrationProviderEnum   `json:"provider"`
	IntegrationType   IntegrationTypeEnum       `json:"integration_type"`
	ExternalAccountID string                    `json:"external_account_id"`
	Status            NullIntegrationStatusEnum `json:"status"`
	AccessToken       pgtype.Text               `json:"access_token"`
	RefreshToken      pgtype.Text               `json:"refresh_token"`
	ExpiresAt         pgtype.Timestamptz        `json:"expires_at"`
	Scopes            interface{}               `json:"scopes"`
}

func (q *Queries) UpsertIntegrationConnection(ctx context.Context, arg UpsertIntegrationConnectionParams) (IntegrationConnection, error) {
	row := q.db.QueryRow(ctx, upsertIntegrationConnection,
		arg.TenantID,
		arg.UserID,
		arg.Provider,
		arg.IntegrationType,
		arg.ExternalAccountID,
		arg.Status,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.Scopes,
	)
	var i IntegrationConnection
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Provider,
		&i.IntegrationType,
		&i.ExternalAccountID,
		&i.Status,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
